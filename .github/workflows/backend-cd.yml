name: CD - Deploy Backend Services to AKS

on:
  workflow_dispatch:
    inputs:
      aks_cluster_name:
        description: 'Name of the AKS Cluster to deploy to'
        required: true
        default: '<aks_cluster_name>'
      aks_resource_group:
        description: 'Resource Group of the AKS Cluster'
        required: true
        default: '<resource_group_name>'
      aks_acr_name:
        description: 'Name of ACR'
        required: true
        default: '<acr_name>'

jobs:
  deploy_backend:
    runs-on: ubuntu-latest
    environment: Production

    outputs:
      PRODUCT_API_IP: ${{ steps.expose.outputs.product_ip }}
      ORDER_API_IP:   ${{ steps.expose.outputs.order_ip }}

    env:
      NAMESPACE: backend
      PRODUCT_SVC: product-service-w08e1
      ORDER_SVC:   order-service-w08e1

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Log in to Azure
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
          enable-AzPSSession: true

      - name: Set Kubernetes context (get AKS credentials)
        run: |
          az aks get-credentials \
            --resource-group "${{ github.event.inputs.aks_resource_group }}" \
            --name "${{ github.event.inputs.aks_cluster_name }}" \
            --overwrite-existing

      - name: Attach ACR
        run: |
          az aks update \
            --name "${{ github.event.inputs.aks_cluster_name }}" \
            --resource-group "${{ github.event.inputs.aks_resource_group }}" \
            --attach-acr "${{ github.event.inputs.aks_acr_name }}"

      - name: Ensure namespace exists
        run: |
          kubectl get ns "$NAMESPACE" >/dev/null 2>&1 || kubectl create namespace "$NAMESPACE"

      - name: Deploy Backend Infrastructure (Namespace, ConfigMaps, Secrets, Databases)
        working-directory: k8s
        run: |
          echo "Deploying backend infrastructure to namespace: $NAMESPACE"
          kubectl apply -f configmaps.yaml -n "$NAMESPACE"
          kubectl apply -f secrets.yaml    -n "$NAMESPACE"
          kubectl apply -f product-db.yaml -n "$NAMESPACE"
          kubectl apply -f order-db.yaml   -n "$NAMESPACE"

      - name: Deploy Backend Microservices (Product, Order)
        working-directory: k8s
        run: |
          echo "Deploying backend microservices to namespace: $NAMESPACE"
          kubectl apply -f product-service.yaml -n "$NAMESPACE"
          kubectl apply -f order-service.yaml   -n "$NAMESPACE"

      - name: Verify rollouts (fail fast)
        run: |
          set -e
          # Update these deployment names only if your YAML uses different names
          kubectl rollout status deploy/product-deploy -n "$NAMESPACE" --timeout=180s
          kubectl rollout status deploy/order-deploy   -n "$NAMESPACE" --timeout=180s

      - name: Wait for Backend LoadBalancer IPs (backoff + diagnostics)
        id: wait_ips
        run: |
          set -e

          get_ip () {
            SVC="$1"; NS="$2"
            for i in 1 2 3 4 5 6 7 8 9 10; do
              ip=$(kubectl get svc "$SVC" -n "$NS" -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
              if [ -n "$ip" ]; then
                echo "$ip"
                return 0
              fi
              echo "No IP for $SVC yet (attempt $i/10). Waiting $((i*6))s..."
              sleep $((i*6))  # 6s..60s
            done
            return 1
          }

          PRODUCT_IP=$(get_ip "${PRODUCT_SVC}" "$NAMESPACE") || {
            echo "Error: No IP for ${PRODUCT_SVC} after timeout."
            kubectl describe svc "${PRODUCT_SVC}" -n "$NAMESPACE" || true
            kubectl get events -n "$NAMESPACE" --sort-by=.lastTimestamp | tail -n 200 || true
            exit 1
          }

          ORDER_IP=$(get_ip "${ORDER_SVC}" "$NAMESPACE") || {
            echo "Error: No IP for ${ORDER_SVC} after timeout."
            kubectl describe svc "${ORDER_SVC}" -n "$NAMESPACE" || true
            kubectl get events -n "$NAMESPACE" --sort-by=.lastTimestamp | tail -n 200 || true
            exit 1
          }

          echo "PRODUCT_IP=$PRODUCT_IP" >> $GITHUB_ENV
          echo "ORDER_IP=$ORDER_IP"     >> $GITHUB_ENV

      - name: Capture IPs as job outputs
        id: expose
        run: |
          echo "product_ip=${PRODUCT_IP}" >> $GITHUB_OUTPUT
          echo "order_ip=${ORDER_IP}"     >> $GITHUB_OUTPUT
          echo "Product Service IP: ${PRODUCT_IP}"
          echo "Order Service IP:   ${ORDER_IP}"

      - name: Logout from Azure
        if: always()
        run: az logout